package main

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"log"
	"math"
	"net/http"
	"os"

	"github.com/sethvargo/go-password/password"
	"gopkg.in/yaml.v2"
	v1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/tools/clientcmd"
)

const namespace = "global-secrets"

type RandomSecret struct {
	Name          string   `yaml:"name"`
	SyncTo        []string `yaml:"syncTo,omitempty"`        // ["kubernetes", "vaultwarden"]
	SyncDirection string   `yaml:"syncDirection,omitempty"` // "kubernetes-to-vaultwarden", "vaultwarden-to-kubernetes", "bidirectional"
	Data          []struct {
		Key     string `yaml:"key"`
		Length  int    `yaml:"length"`
		Special bool   `yaml:"special"`
	} `yaml:"data"`
}

type VaultwardenItem struct {
	Name   string `json:"name"`
	Notes  string `json:"notes"`
	Fields []struct {
		Name  string `json:"name"`
		Value string `json:"value"`
		Type  int    `json:"type"` // 0 = text, 1 = hidden
	} `json:"fields"`
}

func getClient() (*kubernetes.Clientset, error) {
	rules := clientcmd.NewDefaultClientConfigLoadingRules()
	overrides := &clientcmd.ConfigOverrides{}

	config, err := clientcmd.NewNonInteractiveDeferredLoadingClientConfig(rules, overrides).ClientConfig()
	if err != nil {
		return nil, fmt.Errorf("Error building client config: %v", err)
	}

	return kubernetes.NewForConfig(config)
}

func generateRandomPassword(length int, special bool) (string, error) {
	numDigits := int(math.Ceil(float64(length) * 0.2))
	numSymbols := 0

	if special {
		numSymbols = int(math.Ceil(float64(length) * 0.2))
	}

	return password.Generate(length, numDigits, numSymbols, false, true)
}

func getVaultwardenItem(secretName string) (*VaultwardenItem, error) {
	// Use the webhook endpoint instead of direct API
	webhookURL := "http://vaultwarden-cli.global-secrets.svc.cluster.local:8087/object/item/" + secretName
	
	req, err := http.NewRequest("GET", webhookURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating webhook request: %v", err)
	}
	
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending webhook request: %v", err)
	}
	defer resp.Body.Close()
	
	if resp.StatusCode == http.StatusNotFound {
		return nil, nil // Item not found
	}
	
	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("webhook returned status %d", resp.StatusCode)
	}
	
	var item VaultwardenItem
	if err := json.NewDecoder(resp.Body).Decode(&item); err != nil {
		return nil, fmt.Errorf("error decoding webhook response: %v", err)
	}
	
	return &item, nil
}

func getVaultwardenSecretData(item *VaultwardenItem) map[string]string {
	secretData := make(map[string]string)
	
	if item == nil {
		return secretData
	}
	
	for _, field := range item.Fields {
		secretData[field.Name] = field.Value
	}
	
	return secretData
}

func syncToVaultwarden(secretName string, secretData map[string]string) error {
	// Use the webhook endpoint to create/update the item
	webhookURL := "http://vaultwarden-cli.global-secrets.svc.cluster.local:8087/object/item/" + secretName
	
	// Create Vaultwarden item structure
	item := VaultwardenItem{
		Name:  secretName,
		Notes: fmt.Sprintf("Generated by secret-generator for %s", secretName),
	}
	
	// Add each secret as a field
	for key, value := range secretData {
		item.Fields = append(item.Fields, struct {
			Name  string `json:"name"`
			Value string `json:"value"`
			Type  int    `json:"type"`
		}{
			Name:  key,
			Value: value,
			Type:  1, // Hidden field type
		})
	}
	
	// Marshal to JSON
	jsonData, err := json.Marshal(item)
	if err != nil {
		return fmt.Errorf("error marshaling item to JSON: %v", err)
	}
	
	// Create HTTP request to webhook
	req, err := http.NewRequest("POST", webhookURL, bytes.NewBuffer(jsonData))
	if err != nil {
		return fmt.Errorf("error creating webhook request: %v", err)
	}
	
	req.Header.Set("Content-Type", "application/json")
	
	// Send request
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending webhook request: %v", err)
	}
	defer resp.Body.Close()
	
	if resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusCreated {
		return fmt.Errorf("webhook returned status %d", resp.StatusCode)
	}
	
	log.Printf("Successfully synced secret '%s' to Vaultwarden via webhook", secretName)
	return nil
}

func readConfigFile(filename string) ([]RandomSecret, error) {
	data, err := os.ReadFile(filename)
	if err != nil {
		return nil, fmt.Errorf("Unable to read config file: %v", err)
	}

	var randomSecrets []RandomSecret
	err = yaml.Unmarshal(data, &randomSecrets)
	if err != nil {
		return nil, fmt.Errorf("Error parsing config file: %v", err)
	}

	return randomSecrets, nil
}

func createOrUpdateSecret(client *kubernetes.Clientset, name string, randomSecret RandomSecret) error {
	// Set default sync direction if not specified
	syncDirection := randomSecret.SyncDirection
	if syncDirection == "" {
		syncDirection = "kubernetes-to-vaultwarden" // Default behavior
	}
	
	// Get existing data from both sources
	var k8sSecretData map[string]string
	var vaultwardenSecretData map[string]string
	
	// Get Kubernetes secret data
	secret, k8sErr := client.CoreV1().Secrets(namespace).Get(context.Background(), name, metav1.GetOptions{})
	if k8sErr == nil {
		k8sSecretData = make(map[string]string)
		for key, value := range secret.Data {
			k8sSecretData[key] = string(value)
		}
	}
	
	// Get Vaultwarden data if needed
	if contains(randomSecret.SyncTo, "vaultwarden") {
		vaultwardenItem, err := getVaultwardenItem(name)
		if err != nil {
			log.Printf("Warning: Could not get Vaultwarden item '%s': %v", name, err)
			vaultwardenSecretData = make(map[string]string)
		} else {
			vaultwardenSecretData = getVaultwardenSecretData(vaultwardenItem)
		}
	}
	
	// Determine the source of truth based on sync direction
	var finalSecretData map[string]string
	
	switch syncDirection {
	case "vaultwarden-to-kubernetes":
		// Vaultwarden is source of truth
		finalSecretData = vaultwardenSecretData
		// Generate missing keys
		for _, randomPassword := range randomSecret.Data {
			if _, exists := finalSecretData[randomPassword.Key]; !exists {
				password, err := generateRandomPassword(randomPassword.Length, randomPassword.Special)
				if err != nil {
					log.Printf("Error generating password for key '%s': %v", randomPassword.Key, err)
					continue
				}
				finalSecretData[randomPassword.Key] = password
				log.Printf("Generated new password for missing key '%s'", randomPassword.Key)
			}
		}
		
	case "bidirectional":
		// Merge both sources, preferring newer values
		finalSecretData = make(map[string]string)
		
		// Start with Kubernetes data
		for key, value := range k8sSecretData {
			finalSecretData[key] = value
		}
		
		// Overlay Vaultwarden data (you could add timestamp logic here)
		for key, value := range vaultwardenSecretData {
			finalSecretData[key] = value
		}
		
		// Generate missing keys
		for _, randomPassword := range randomSecret.Data {
			if _, exists := finalSecretData[randomPassword.Key]; !exists {
				password, err := generateRandomPassword(randomPassword.Length, randomPassword.Special)
				if err != nil {
					log.Printf("Error generating password for key '%s': %v", randomPassword.Key, err)
					continue
				}
				finalSecretData[randomPassword.Key] = password
				log.Printf("Generated new password for missing key '%s'", randomPassword.Key)
			}
		}
		
	default: // "kubernetes-to-vaultwarden"
		// Kubernetes is source of truth
		finalSecretData = k8sSecretData
		if finalSecretData == nil {
			finalSecretData = make(map[string]string)
		}
		
		// Generate missing keys
		for _, randomPassword := range randomSecret.Data {
			if _, exists := finalSecretData[randomPassword.Key]; !exists {
				password, err := generateRandomPassword(randomPassword.Length, randomPassword.Special)
				if err != nil {
					log.Printf("Error generating password for key '%s': %v", randomPassword.Key, err)
					continue
				}
				finalSecretData[randomPassword.Key] = password
				log.Printf("Generated new password for missing key '%s'", randomPassword.Key)
			}
		}
	}
	
	// Sync to Kubernetes if specified
	if contains(randomSecret.SyncTo, "kubernetes") {
		secretDataBytes := make(map[string][]byte)
		for key, value := range finalSecretData {
			secretDataBytes[key] = []byte(value)
		}
		
		if k8sErr != nil {
			// Secret doesn't exist, create it
			newSecret := &v1.Secret{
				ObjectMeta: metav1.ObjectMeta{
					Name:      name,
					Namespace: namespace,
				},
				Data: secretDataBytes,
			}
			
			_, err := client.CoreV1().Secrets(namespace).Create(context.Background(), newSecret, metav1.CreateOptions{})
			if err != nil {
				return fmt.Errorf("Unable to create secret: %v", err)
			}
			log.Printf("Secret '%s' created successfully in Kubernetes.", name)
		} else {
			// Secret exists, update it
			secret.Data = secretDataBytes
			_, err := client.CoreV1().Secrets(namespace).Update(context.Background(), secret, metav1.UpdateOptions{})
			if err != nil {
				return fmt.Errorf("Unable to update secret: %v", err)
			}
			log.Printf("Secret '%s' updated successfully in Kubernetes.", name)
		}
	}
	
	// Sync to Vaultwarden if specified
	if contains(randomSecret.SyncTo, "vaultwarden") {
		err := syncToVaultwarden(name, finalSecretData)
		if err != nil {
			log.Printf("Error syncing to Vaultwarden: %v", err)
		}
	}
	
	return nil
}

func contains(slice []string, item string) bool {
	for _, s := range slice {
		if s == item {
			return true
		}
	}
	return false
}

func main() {
	configFilename := "./config.yaml"
	randomSecrets, err := readConfigFile(configFilename)
	if err != nil {
		log.Fatalf("Error reading config file: %v", err)
	}

	client, err := getClient()
	if err != nil {
		log.Fatalf("Unable to create Kubernetes client: %v", err)
	}

	for _, randomSecret := range randomSecrets {
		// Default to Kubernetes if no syncTo specified (backward compatibility)
		if len(randomSecret.SyncTo) == 0 {
			randomSecret.SyncTo = []string{"kubernetes"}
		}
		
		err := createOrUpdateSecret(client, randomSecret.Name, randomSecret)
		if err != nil {
			log.Printf("Error processing secret %s: %v", randomSecret.Name, err)
		}
	}
}
