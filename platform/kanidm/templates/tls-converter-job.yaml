apiVersion: v1
kind: ServiceAccount
metadata:
  name: {{ .Release.Name }}-tls-converter
  namespace: {{ .Release.Namespace }}
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: {{ .Release.Name }}-tls-converter
  namespace: {{ .Release.Namespace }}
rules:
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["get", "patch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: {{ .Release.Name }}-tls-converter
  namespace: {{ .Release.Namespace }}
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: {{ .Release.Name }}-tls-converter
subjects:
- kind: ServiceAccount
  name: {{ .Release.Name }}-tls-converter
  namespace: {{ .Release.Namespace }}
---
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ .Release.Name }}-tls-converter
  namespace: {{ .Release.Namespace }}
  annotations:
    "argocd.argoproj.io/hook": PreSync
    "argocd.argoproj.io/hook-delete-policy": HookSucceeded,HookFailed
spec:
  backoffLimit: 3
  ttlSecondsAfterFinished: 86400
  template:
    spec:
      serviceAccountName: {{ .Release.Name }}-tls-converter
      restartPolicy: Never
      containers:
      - name: convert-tls
        image: bitnami/kubectl:latest
        command:
        - /bin/bash
        - -c
        - |
          set -e
          SECRET_NAME="{{ .Release.Name }}-selfsigned-certificate"
          NAMESPACE="{{ .Release.Namespace }}"
          
          echo "Waiting for secret $SECRET_NAME in namespace $NAMESPACE..."
          for i in {1..30}; do
            if kubectl get secret "$SECRET_NAME" -n "$NAMESPACE" 2>/dev/null; then
              echo "Secret found!"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "Secret not found after 60 seconds"
              exit 1
            fi
            sleep 2
          done
          
          echo "Checking TLS key format..."
          kubectl get secret "$SECRET_NAME" -n "$NAMESPACE" -o jsonpath='{.data.tls\.key}' | base64 -d > /tmp/tls.key
          
          if grep -q "BEGIN RSA PRIVATE KEY" /tmp/tls.key; then
            echo "Converting PKCS#1 to PKCS#8..."
            openssl pkcs8 -topk8 -nocrypt -in /tmp/tls.key -out /tmp/tls.key.pkcs8
            ENCODED_KEY=$(base64 -w0 < /tmp/tls.key.pkcs8)
            kubectl patch secret "$SECRET_NAME" -n "$NAMESPACE" -p "{\"data\":{\"tls.key\":\"$ENCODED_KEY\"}}"
            echo "Secret patched with PKCS#8 key"
          else
            echo "Key is already in PKCS#8 format"
          fi
